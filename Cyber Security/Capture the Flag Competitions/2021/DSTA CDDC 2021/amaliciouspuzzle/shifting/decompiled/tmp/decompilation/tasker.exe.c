//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _addTask(int32_t a1, int32_t a2, int32_t a3);
int32_t _atexit(int32_t a1);
int32_t _ensureExtraCapacity(int32_t * a1);
int32_t _getLeftChildIndex(int32_t a1);
int32_t _getParentIndex(int32_t a1);
int32_t _getRightChildIndex(int32_t a1);
int32_t _hasLeftChild(int32_t a1);
int32_t _hasParent(int32_t a1);
int32_t _hasRightChild(int32_t a1);
int32_t _heapifyDown(int32_t a1);
int32_t _heapifyUp(int32_t a1);
int32_t _leftChild(int32_t a1, int32_t a2);
int32_t _parent(int32_t a1, int32_t a2);
int32_t _peek(int32_t a1);
int32_t _poll(int32_t a1);
int32_t _rightChild(int32_t a1, int32_t a2);
int32_t _swap(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g1 = -1; // 0x402d10
int32_t g2 = 10; // 0x403008
int32_t g3 = 0; // 0x406034
int32_t g4 = 0; // 0x4063e4

// ------------------------ Functions -------------------------

// Address range: 0x4014c0 - 0x4014dd
int32_t _atexit(int32_t a1) {
    // 0x4014c0
    return _onexit((int32_t (*)())a1) == NULL;
}

// Address range: 0x4015c0 - 0x401824
int main(int argc, char ** argv) {
    // 0x4015c0
    ___main();
    int32_t * mem = malloc(4 * g2); // 0x4015d9
    puts("\tIn this program the greater the priority value of the task, the higher is the priority of the task");
    for (int32_t i = 0; i < 110; i++) {
        // 0x4015f8
        putchar(45);
    }
    int32_t v1 = (int32_t)mem; // 0x4015d9
    putchar(10);
    int32_t v2; // 0x4015c0
    int32_t v3; // 0x4015c0
    int32_t v4; // bp-40, 0x4015c0
    while (true) {
      lab_0x40161c:;
        int32_t v5 = v2;
        puts("1...Enter a new task");
        puts("2...Remove highest priority task");
        puts("3...Show highest priority task");
        puts("4...Exit");
        puts("Enter you option below:");
        printf("-> ");
        scanf("%d", &v4);
        putchar(10);
        int32_t v6; // bp-32, 0x4015c0
        int32_t v7; // bp-36, 0x4015c0
        if (v4 == 2) {
            // 0x401733
            v7 = _poll(v1);
            v6 = v5;
            puts("Element Processed is:");
            printf("ID: %d\n", v7);
            printf("Priority: %d\n", v6);
            v3 = v5;
            goto lab_0x4017d6;
        } else {
            if (v4 > 2) {
                // 0x4016a0
                v3 = v5;
                switch (v4) {
                    case 3: {
                        // 0x40177d
                        v7 = _peek(v1);
                        v6 = v5;
                        puts("Element Ready to be Processed first is:");
                        printf("ID: %d\n", v7);
                        printf("Priority: %d\n", v6);
                        v3 = v5;
                        goto lab_0x4017d6;
                    }
                    case 4: {
                        goto lab_0x4017d6;
                    }
                    default: {
                        // 0x4017c7
                        puts("Invalid option entered, please try again !\n");
                        v3 = v5;
                        goto lab_0x4017d6;
                    }
                }
            } else {
                if (v4 == 1) {
                    // 0x4016b7
                    puts("Enter the task ID:");
                    printf("-> ");
                    scanf("%d", &v7);
                    puts("Enter the task Priority:");
                    printf("-> ");
                    scanf("%d", &v6);
                    _addTask(v7, v6, v1);
                    v3 = v6;
                    goto lab_0x4017d6;
                } else {
                    // 0x4017c7
                    puts("Invalid option entered, please try again !\n");
                    v3 = v5;
                    goto lab_0x4017d6;
                }
            }
        }
    }
  lab_0x401811:
    // 0x401811
    free(mem);
    return 0;
  lab_0x4017d6:
    // 0x4017d6
    putchar(45);
    int32_t v8 = 1; // 0x4017ec
    int32_t v9 = v8; // 0x4017f6
    while (v8 != 100) {
        // 0x4017e0
        putchar(45);
        v8 = v9 + 1;
        v9 = v8;
    }
    // 0x4017f8
    putchar(10);
    v2 = v3;
    if (v4 == 4) {
        // break -> 0x401811
        goto lab_0x401811;
    }
    goto lab_0x40161c;
}

// Address range: 0x401824 - 0x4018f2
int32_t _heapifyDown(int32_t a1) {
    int32_t v1 = _getLeftChildIndex(0); // 0x401838
    int32_t result = _hasLeftChild(0); // 0x4018db
    if ((char)result == 0) {
        // 0x4018eb
        return result;
    }
    int32_t v2 = a1 + 4;
    int32_t * v3 = (int32_t *)(8 * v1 + v2);
    v1 = 0;
    if ((char)_hasRightChild(v1) != 0) {
        // 0x401854
        _rightChild(v1, a1);
        _leftChild(v1, a1);
    }
    int32_t v4 = *v3; // 0x4018af
    int32_t result2 = v4; // 0x4018b4
    while (*(int32_t *)(8 * v1 + v2) <= v4) {
        // 0x4018b6
        _swap(v1, v1, a1);
        int32_t v5 = _hasLeftChild(v1); // 0x4018db
        result2 = v5;
        if ((char)v5 == 0) {
            // break -> 0x4018eb
            break;
        }
        if ((char)_hasRightChild(v1) != 0) {
            // 0x401854
            _rightChild(v1, a1);
            _leftChild(v1, a1);
        }
        // 0x40188e
        v4 = *v3;
        result2 = v4;
    }
    // 0x4018eb
    return result2;
}

// Address range: 0x4018f2 - 0x401972
int32_t _heapifyUp(int32_t a1) {
    int32_t v1 = g4 - 1; // 0x4018fd
    int32_t result = _hasParent(v1); // 0x40193c
    if ((char)result == 0) {
        // 0x40196f
        return result;
    }
    int32_t v2 = v1; // 0x40192e
    _parent(v2, a1);
    uint32_t v3 = *(int32_t *)(a1 + 4 + 8 * v2); // 0x401968
    int32_t result2 = v3; // 0x40196d
    int32_t v4; // 0x4018f2
    while (v4 < v3) {
        int32_t v5 = _getParentIndex(v2); // 0x40190b
        _swap(v5, v2, a1);
        v2 = _getParentIndex(v2);
        int32_t v6 = _hasParent(v2); // 0x40193c
        v4 = v5;
        result2 = v6;
        if ((char)v6 == 0) {
            // break -> 0x40196f
            break;
        }
        _parent(v2, a1);
        v3 = *(int32_t *)(a1 + 4 + 8 * v2);
        result2 = v3;
    }
    // 0x40196f
    return result2;
}

// Address range: 0x401972 - 0x4019b8
int32_t _addTask(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3;
    _ensureExtraCapacity(&v1);
    int32_t v2 = 8 * g4 + v1; // 0x40198f
    *(int32_t *)v2 = a1;
    *(int32_t *)(v2 + 4) = a2;
    g4++;
    return _heapifyUp(v1);
}

// Address range: 0x4019b8 - 0x401a30
int32_t _poll(int32_t a1) {
    // 0x4019b8
    if (g4 == 0) {
        // 0x4019c7
        puts("Error !");
        exit(0);
        // UNREACHABLE
    }
    int32_t * v1 = (int32_t *)a1; // 0x4019e5
    int32_t v2 = a1 - 8 + 8 * g4; // 0x401a01
    *v1 = *(int32_t *)v2;
    *(int32_t *)(a1 + 4) = *(int32_t *)(v2 + 4);
    g4--;
    _heapifyDown(a1);
    return *v1;
}

// Address range: 0x401a30 - 0x401a61
int32_t _peek(int32_t a1) {
    // 0x401a30
    if (g4 != 0) {
        // 0x401a57
        return *(int32_t *)a1;
    }
    // 0x401a3f
    puts("Error !");
    exit(0);
    // UNREACHABLE
}

// Address range: 0x401a61 - 0x401ab6
int32_t _ensureExtraCapacity(int32_t * a1) {
    int32_t v1 = 2 * g2; // 0x401a6c
    int32_t result = g4; // 0x401a86
    if (v1 / 3 < g4) {
        // 0x401a88
        g2 = v1;
        *a1 = (int32_t)realloc((int32_t *)*a1, v1);
        result = (int32_t)a1;
    }
    // 0x401ab3
    return result;
}

// Address range: 0x401ab6 - 0x401b1c
int32_t _swap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 8 * a1 + a3; // 0x401ac9
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x401acb
    int32_t * v3 = (int32_t *)v1; // 0x401ace
    int32_t result = *v3; // 0x401ace
    int32_t v4 = 8 * a2 + a3; // 0x401ae3
    int32_t * v5 = (int32_t *)(v4 + 4); // 0x401af4
    int32_t * v6 = (int32_t *)v4; // 0x401af7
    *v3 = *v6;
    *v2 = *v5;
    *v6 = result;
    *v5 = *v2;
    return result;
}

// Address range: 0x401b1c - 0x401b40
int32_t _parent(int32_t a1, int32_t a2) {
    // 0x401b1c
    return *(int32_t *)(8 * _getParentIndex(a1) + a2);
}

// Address range: 0x401b40 - 0x401b64
int32_t _rightChild(int32_t a1, int32_t a2) {
    // 0x401b40
    return *(int32_t *)(8 * _getRightChildIndex(a1) + a2);
}

// Address range: 0x401b64 - 0x401b88
int32_t _leftChild(int32_t a1, int32_t a2) {
    // 0x401b64
    return *(int32_t *)(8 * _getLeftChildIndex(a1) + a2);
}

// Address range: 0x401b88 - 0x401ba0
int32_t _hasParent(int32_t a1) {
    // 0x401b88
    return _getParentIndex(a1) > -1;
}

// Address range: 0x401ba0 - 0x401bbf
int32_t _hasRightChild(int32_t a1) {
    int32_t v1 = _getRightChildIndex(a1); // 0x401bac
    int32_t v2 = g4; // 0x401bb3
    int32_t v3 = v1 - v2; // 0x401bb8
    return v2 & -256 | (int32_t)(v3 < 0 != ((v3 ^ v1) & (v2 ^ v1)) < 0);
}

// Address range: 0x401bbf - 0x401bde
int32_t _hasLeftChild(int32_t a1) {
    int32_t v1 = _getLeftChildIndex(a1); // 0x401bcb
    int32_t v2 = g4; // 0x401bd2
    int32_t v3 = v1 - v2; // 0x401bd7
    return v2 & -256 | (int32_t)(v3 < 0 != ((v3 ^ v1) & (v2 ^ v1)) < 0);
}

// Address range: 0x401bde - 0x401beb
int32_t _getLeftChildIndex(int32_t a1) {
    // 0x401bde
    return 2 * a1 | 1;
}

// Address range: 0x401beb - 0x401bf8
int32_t _getRightChildIndex(int32_t a1) {
    // 0x401beb
    return 2 * a1 + 2;
}

// Address range: 0x401bf8 - 0x401c0c
int32_t _getParentIndex(int32_t a1) {
    int32_t v1 = a1 - 1; // 0x401bfe
    return (v1 + (int32_t)(v1 < 0)) / 2;
}

// Address range: 0x401c50 - 0x401c96
int32_t ___do_global_ctors(void) {
    int32_t v1 = 0;
    int32_t v2 = v1 + 1; // 0x401c86
    while (*(int32_t *)(4 * v2 + (int32_t)&g1) != 0) {
        // 0x401c86
        v1 = v2;
        v2 = v1 + 1;
    }
    // 0x401c94
    if (v1 == 0) {
        // 0x401c6f
        return _atexit(0x401c10);
    }
    int32_t v3 = v1; // 0x401c61
    while (v3 != 1) {
        // 0x401c63
        v3--;
    }
    // 0x401c6f
    return _atexit(0x401c10);
}

// Address range: 0x401ca0 - 0x401cbc
int32_t ___main(void) {
    int32_t result = g3; // 0x401ca0
    if (result != 0) {
        // 0x401ca9
        return result;
    }
    // 0x401cb0
    g3 = 1;
    return ___do_global_ctors();
}

// --------------- Dynamically Linked Functions ---------------

// _onexit_t _onexit(_onexit_t Function);
// void exit(int status);
// void free(void * ptr);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// int putchar(int c);
// int puts(const char * s);
// void * realloc(void * ptr, size_t size);
// int scanf(const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (8.1.0)
// Detected language: C
// Detected functions: 20
